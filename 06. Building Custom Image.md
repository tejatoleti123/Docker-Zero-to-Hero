
# 06. Building Custom Image

In the previous section, we ran containers using existing images like nginx and ubuntu.

We also mounted files into containers to customize behavior.

Now we take the next step:

Instead of modifying containers at runtime, we will build our own image using a Dockerfile.

This is how real-world applications are containerized.

---

# ğŸ§± What Is a Dockerfile?

A Dockerfile is a text file that contains instructions for building a Docker image.

Each instruction creates a new layer in the image.

Docker reads the Dockerfile step-by-step and builds the image accordingly.

---

# ğŸ§ª Practical Example: Build a Simple Web Application Image

We will create a small Python web application and containerize it.

---

## Step 1: Create a Project Directory

Create a new folder:

    mkdir my-docker-app
    cd my-docker-app

---

## Step 2: Create Application File

Create a file named:

    app.py

Add the following content:

    from flask import Flask

    app = Flask(__name__)

    @app.route("/")
    def home():
        return "Hello from my custom Docker image!"

    if __name__ == "__main__":
        app.run(host="0.0.0.0", port=5000)

---

## Step 3: Create requirements.txt

Create a file named:

    requirements.txt

Add:

    flask==2.3.2

---

## Step 4: Create Dockerfile

Create a file named:

    Dockerfile

Add the following:

    FROM python:3.11-alpine

    WORKDIR /app

    COPY requirements.txt .

    RUN pip install --no-cache-dir -r requirements.txt

    COPY app.py .

    EXPOSE 5000

    CMD ["python", "app.py"]

---

# ğŸ§  Understanding Each Dockerfile Instruction

## FROM

    FROM python:3.11-alpine

Defines the base image.

Alpine is a lightweight Linux distribution, which keeps the image small.

---

## WORKDIR

    WORKDIR /app

Sets the working directory inside the container.

If the directory does not exist, Docker creates it.

---

## COPY

    COPY requirements.txt .

Copies files from your local machine into the container image.

---

## RUN

    RUN pip install --no-cache-dir -r requirements.txt

Executes commands during image build.

This installs dependencies.

---

## EXPOSE

    EXPOSE 5000

Documents that the container listens on port 5000.

It does not publish the port automatically.

---

## CMD

    CMD ["python", "app.py"]

Defines the default command that runs when the container starts.

---

# ğŸ— Step 5: Build the Image

Inside the project directory, run:

    docker build -t my-flask-app:v1 .

Explanation:

- `-t` â†’ Tag the image  
- `my-flask-app` â†’ Image name  
- `v1` â†’ Version tag  
- `.` â†’ Build context (current directory)  

Docker will:

1. Read Dockerfile  
2. Execute instructions step-by-step  
3. Create image layers  
4. Build final image  

---

# ğŸ“¦ View Your Image

To list images:

    docker images

You should see:

    my-flask-app    v1

---

# ğŸš€ Step 6: Run Your Custom Image

Run:

    docker run -p 5000:5000 my-flask-app:v1

Now open:

    http://localhost:5000

You should see:

    Hello from my custom Docker image!

You have successfully built and run your own container image.

---

# ğŸ§  Understanding Image Layers

Each Dockerfile instruction creates a layer.

Layers are:

- Cached
- Reusable
- Immutable

If you rebuild without changing requirements.txt, Docker uses cache and builds faster.

This layer system makes Docker efficient.

---

# ğŸ· Image Tagging Best Practice

Instead of using:

    my-flask-app:latest

Use versioned tags:

    my-flask-app:v1
    my-flask-app:v1.0.1

In production, avoid using `latest`.

Versioned images improve traceability and rollback capability.

---

# ğŸ§  Key Takeaways

- Dockerfile defines how images are built.
- Each instruction creates a layer.
- `docker build` creates images.
- Images must be tagged properly.
- Containers are created from images.
- Avoid using `latest` in production.

You have now moved from running containers to creating your own container images.

This is a major step in your Docker journey.

---

## ğŸ”œ Next Step

Now that you can build images locally, the next logical step is:

How do we share our images with others?

ğŸ‘‰ [07. Publishing Image to DockerHub](./07.%20Publishing%20Image%20to%20DockerHub.md)

In the next section, we will:

- Create a Docker Hub account
- Tag images properly
- Push images to a registry
- Pull images from Docker Hub
