# 09. Multi Stage Builds & Distroless Images

In the previous section, we learned about volumes and networking â€” how containers persist data and communicate.

Now we move into advanced image optimization and security techniques.

When building production-grade containers, two important goals are:

- Reduce image size
- Improve security

This section introduces:

- Multi-stage builds
- Distroless images

These are widely used in modern cloud-native applications.

---

# ğŸ“¦ Why Image Size Matters

Large images cause:

- Slower builds
- Longer push and pull times
- Increased storage usage
- Larger attack surface
- Slower deployments

Smaller images:

- Deploy faster
- Start faster
- Reduce bandwidth usage
- Improve security posture

Optimizing images is critical in production environments.

---

# ğŸ§± Multi-Stage Builds

Multi-stage builds allow you to use multiple `FROM` statements in a single Dockerfile.

This enables:

- Build environment separation
- Smaller final images
- Cleaner production containers

---

## ğŸ§ª Example: Without Multi-Stage Build

Consider this Dockerfile:

    FROM node:18

    WORKDIR /app
    COPY package.json .
    RUN npm install

    COPY . .

    CMD ["node", "app.js"]

This image includes:

- Node runtime
- Build tools
- Source code
- Dependencies
- Development files

It may become large.

---

## ğŸ§ª Example: With Multi-Stage Build

    FROM node:18 AS builder

    WORKDIR /app
    COPY package.json .
    RUN npm install

    COPY . .
    RUN npm run build

    FROM node:18-alpine

    WORKDIR /app
    COPY --from=builder /app/dist ./dist

    CMD ["node", "dist/app.js"]

What happens here:

Stage 1 (builder):
- Installs dependencies
- Builds the application

Stage 2 (final image):
- Copies only built output
- Excludes development dependencies
- Uses lightweight base image

Result:
- Smaller image
- Cleaner runtime environment

---

# ğŸ§  How Multi-Stage Works

Each `FROM` creates a new stage.

You can reference previous stages using:

    COPY --from=stage_name

Only necessary artifacts are copied into the final image.

Everything else is discarded.

---

# ğŸª¶ Distroless Images

Distroless images are minimal base images that contain:

- Application runtime
- Required libraries

They do NOT include:

- Package managers
- Shell
- Debugging tools

This reduces attack surface significantly.

---

## ğŸ” Why Distroless Is More Secure

Traditional images include:

- bash
- apt
- curl
- system utilities

Distroless images remove these.

Benefits:

- Smaller image size
- Reduced vulnerability surface
- Fewer exploitable components

---

## ğŸ§ª Example Using Distroless (Conceptual)

    FROM node:18 AS builder

    WORKDIR /app
    COPY package.json .
    RUN npm install
    COPY . .
    RUN npm run build

    FROM gcr.io/distroless/nodejs18

    WORKDIR /app
    COPY --from=builder /app/dist ./dist

    CMD ["dist/app.js"]

Notice:

- No shell
- No package manager
- Only runtime

This is production-grade containerization.

---

# âš ï¸ Important Considerations

Distroless images:

- Cannot use bash inside container
- Harder to debug
- Best suited for production

During development, standard images may be more convenient.

---

# ğŸ§  Multi-Stage vs Single Stage

Single Stage:
- Easier to write
- Larger image

Multi-Stage:
- Slightly more complex
- Much cleaner production image
- Smaller size

In production systems, multi-stage builds are strongly recommended.

---

# ğŸ” Additional Optimization Tips

- Use Alpine-based images where appropriate
- Remove unnecessary dependencies
- Use specific version tags
- Avoid installing build tools in final image
- Run containers as non-root users
- Regularly scan images for vulnerabilities

---

# ğŸ§  Key Takeaways

- Image size impacts performance and security.
- Multi-stage builds separate build and runtime environments.
- Only required artifacts should exist in production images.
- Distroless images reduce attack surface.
- Production containers should be minimal and secure.

You now understand advanced container optimization techniques.

This elevates your Docker knowledge to intermediate and production-ready level.

---

# ğŸ‰ Docker Section Complete

You have now learned:

- Container fundamentals
- Runtime ecosystem
- Docker architecture
- Installation
- Running containers
- Building images
- Publishing images
- Volumes and networking
- Multi-stage builds
- Distroless images

This is a strong Docker foundation.
